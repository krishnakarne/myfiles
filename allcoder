calculateRowSpans(): void {
    const columnKeys = ['date', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];

    // Initialize the rowSpans array for each column
    columnKeys.forEach(column => {
        this.rowSpans[column] = new Array(this.copilotData.filteredData.length).fill(1);
    });

    // Calculate row spans for each column
    columnKeys.forEach(column => {
        let currentSpan = 1;

        for (let i = 1; i < this.copilotData.filteredData.length; i++) {
            if (this.copilotData.filteredData[i][column] === this.copilotData.filteredData[i - 1][column]) {
                currentSpan++;
                this.rowSpans[column][i] = 0; // Mark for hiding
            } else {
                this.rowSpans[column][i - currentSpan] = currentSpan; // Set the rowspan for the starting row
                currentSpan = 1;
            }
        }
        // Apply span for the last series of rows
        this.rowSpans[column][this.copilotData.filteredData.length - currentSpan] = currentSpan;
    });
}

getRowSpan(index: number, column: string): number {
    // Ensure index is within bounds
    if (index < 0 || index >= this.copilotData.filteredData.length) {
        return 1;
    }
    // Return the rowspan or 1 if undefined
    return this.rowSpans[column][index] || 1;
}

export class CopilotDetailsComponent {
  rowSpans: { [key: string]: number[] } = {};

  ngOnInit() {
    this.getRepoInfoData(); // Ensure data is fetched and processed before calculating row spans
  }

  calculateRowSpans(): void {
    const columnKeys = ['date', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];

    columnKeys.forEach(column => {
      this.rowSpans[column] = []; // Initialize the array for each column
      let currentSpan = 1;

      for (let i = 1; i < this.copilotData.filteredData.length; i++) {
        if (this.copilotData.filteredData[i][column] === this.copilotData.filteredData[i - 1][column]) {
          currentSpan++;
        } else {
          this.rowSpans[column][i - currentSpan] = currentSpan;
          for (let j = 1; j < currentSpan; j++) {
            this.rowSpans[column][i - j] = 0;
          }
          currentSpan = 1;
        }
      }
      this.rowSpans[column][this.copilotData.filteredData.length - currentSpan] = currentSpan;
    });
  }

  getRowSpan(index: number, column: string): number {
    return this.rowSpans[column] && this.rowSpans[column][index] ? this.rowSpans[column][index] : 1;
  }

  getRepoInfoData() {
    this.http.get<any[]>(this.getCopilotUrl(), this.httpOptions).subscribe(response => {
      this.copilotDetails = response;

      this.copilotData = new MatTableDataSource<any>(response.flatMap((data: any) => {
        return data.breakdown.map((breakdown: any) => {
          return {
            date: data.day,
            total_suggestions_count: data.total_suggestions_count,
            total_acceptances_count: data.total_acceptances_count,
            total_lines_suggested: data.total_lines_suggested,
            total_lines_accepted: data.total_lines_accepted,
            total_active_users: data.total_active_users,
            language: breakdown.language,
            editor: breakdown.editor,
          };
        });
      }));

      this.filteredData = this.copilotData.filteredData; // Ensure filteredData is available
      this.calculateRowSpans(); // Call the row span calculation after data is populated
    });
  }
}





--------------------------------------------------
import { Component, OnInit } from '@angular/core';
import { MatTableDataSource } from '@angular/material/table';

@Component({
  selector: 'app-copilot-details',
  templateUrl: './copilot-details.component.html',
  styleUrls: ['./copilot-details.component.scss']
})
export class CopilotDetailsComponent implements OnInit {
  displayedColumns: string[] = ['day', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];
  dataSource: MatTableDataSource<any>;

  copilotData = [
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'JavaScript', editor: 'VSCode' },
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'JavaScript', editor: 'VSCode' },
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'Shell', editor: 'VSCode' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Python', editor: 'PyCharm' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Python', editor: 'PyCharm' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Go', editor: 'VSCode' },
  ];

  rowSpans = {};

  ngOnInit(): void {
    this.dataSource = new MatTableDataSource(this.copilotData);
    this.calculateRowSpans();
  }

  calculateRowSpans(): void {
    const columnKeys = ['day', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];

    columnKeys.forEach(column => {
      this.rowSpans[column] = [];

      let currentSpan = 1;
      for (let i = 0; i < this.copilotData.length; i++) {
        this.rowSpans[column][i] = 1; // Default to 1
        if (i > 0 && this.copilotData[i][column] === this.copilotData[i - 1][column]) {
          currentSpan++;
          this.rowSpans[column][i - currentSpan + 1] = currentSpan; // Update previous rowspan
          this.rowSpans[column][i] = 0; // Current row should be hidden
        } else {
          currentSpan = 1; // Reset span count
        }
      }
    });
  }

  getRowSpan(index: number, column: string): number {
    return this.rowSpans[column] ? this.rowSpans[column][index] : 1;
  }
}


import { Component, OnInit } from '@angular/core';
import { MatTableDataSource } from '@angular/material/table';

@Component({
  selector: 'app-copilot-details',
  templateUrl: './copilot-details.component.html',
  styleUrls: ['./copilot-details.component.scss']
})
export class CopilotDetailsComponent implements OnInit {
  displayedColumns: string[] = ['day', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];
  dataSource: MatTableDataSource<any>;

  copilotData = [
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'JavaScript', editor: 'VSCode' },
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'JavaScript', editor: 'VSCode' },
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'Shell', editor: 'VSCode' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Python', editor: 'PyCharm' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Python', editor: 'PyCharm' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Go', editor: 'VSCode' },
  ];

  rowSpans = {};

  ngOnInit(): void {
    this.dataSource = new MatTableDataSource(this.copilotData);
    this.calculateRowSpans();
  }

  calculateRowSpans(): void {
    const columnKeys = ['day', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];

    columnKeys.forEach(column => {
      this.rowSpans[column] = [];  // Initialize the array

      let currentSpan = 1;
      for (let i = 0; i < this.copilotData.length; i++) {
        if (i === 0 || this.copilotData[i][column] !== this.copilotData[i - 1][column]) {
          if (i > 0) {
            this.rowSpans[column][i - currentSpan] = currentSpan;
          }
          currentSpan = 1;
          this.rowSpans[column][i] = 1;
        } else {
          this.rowSpans[column][i] = 0;
          currentSpan++;
        }
      }

      // Finalize the last group
      if (this.copilotData.length > 0) {
        this.rowSpans[column][this.copilotData.length - currentSpan] = currentSpan;
      }
    });
  }

  getRowSpan(index: number, column: string): number {
    return this.rowSpans[column] ? this.rowSpans[column][index] : 1;
  }
}



import { Component, OnInit } from '@angular/core';
import { MatTableDataSource } from '@angular/material/table';

@Component({
  selector: 'app-copilot-details',
  templateUrl: './copilot-details.component.html',
  styleUrls: ['./copilot-details.component.scss']
})
export class CopilotDetailsComponent implements OnInit {
  displayedColumns: string[] = ['day', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];
  dataSource: MatTableDataSource<any>;

  copilotData = [
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'JavaScript', editor: 'VSCode' },
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'JavaScript', editor: 'VSCode' },
    { day: '2024-07-18', total_suggestions_count: 1050, total_lines_accepted: 416, total_acceptances_count: 291, language: 'Shell', editor: 'VSCode' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Python', editor: 'PyCharm' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Python', editor: 'PyCharm' },
    { day: '2024-07-19', total_suggestions_count: 1120, total_lines_accepted: 450, total_acceptances_count: 320, language: 'Go', editor: 'VSCode' },
  ];

  rowSpans = {};

  ngOnInit(): void {
    this.dataSource = new MatTableDataSource(this.copilotData);
    this.calculateRowSpans();
  }

  calculateRowSpans(): void {
    const columnKeys = ['day', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'language', 'editor'];
    
    columnKeys.forEach(column => {
      this.rowSpans[column] = new Array(this.copilotData.length).fill(1);  // Initialize with 1 (default rowspan)

      for (let i = 0; i < this.copilotData.length; i++) {
        if (i > 0 && this.copilotData[i][column] === this.copilotData[i - 1][column]) {
          this.rowSpans[column][i] = 0;  // Set rowspan to 0 for duplicate entries
          this.rowSpans[column][i - 1] += 1;  // Increment the rowspan of the previous cell
        }
      }
    });
  }

  getRowSpan(index: number, column: string): number {
    return this.rowSpans[column][index];
  }
}



calculateRowSpans() {
  const columnKeys = ['day', 'total_suggestions_count', 'total_lines_accepted', 'total_acceptances_count', 'total_lines_suggested', 'total_active_users', 'language', 'editor'];
  columnKeys.forEach(column => {
    this.rowSpans[column] = this.calculateRowSpanForColumn(column);
  });

  console.log('Calculated rowSpans:', this.rowSpans);  // Check if this logs correct values
}

calculateRowSpanForColumn(column: string): number[] {
  const rowSpans = [];
  let rowIndex = 0;

  while (rowIndex < this.copilotData.length) {
    let spanCount = 1;

    while (rowIndex + spanCount < this.copilotData.length &&
      this.copilotData[rowIndex][column] === this.copilotData[rowIndex + spanCount][column]) {
      spanCount++;
    }

    for (let i = 0; i < spanCount; i++) {
      rowSpans.push(i === 0 ? spanCount : 0); // First cell gets the span, others get 0
    }

    rowIndex += spanCount;
  }

  return rowSpans;
}

getRowSpan(index: number, column: string): number {
  if (this.rowSpans[column] && this.rowSpans[column][index] !== undefined) {
    return this.rowSpans[column][index];
  } else {
    return 1;  // Default to 1 if no span is calculated
  }
}




async renameDiagram(): Promise<void> {
  try {
    const fileData = '<mxGraphModel dx="1038" dy="381" grid="1" gridSize="10" guides="1">...</mxGraphModel>'; // Replace with actual file data

    const blob = new Blob([fileData], { type: 'application/vnd.jgraph.mxfile' });
    const url = window.URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'diagram.drawio'; // Default file name, you can prompt the user for input
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);

    window.URL.revokeObjectURL(url);
    console.log('File saved successfully');
  } catch (error) {
    console.error('Rename failed:', error);
  }
}


import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';
import { NgxSpinnerService } from 'ngx-spinner';
import { GraphEditorIn, GraphXmlData } from 'some-graph-editor-library'; // Replace with actual import

@Component({
  selector: 'app-draw-io-details',
  templateUrl: './draw-io-details.component.html',
  styleUrls: ['./draw-io-details.component.scss'],
})
export class DrawIoDetailsComponent implements OnInit {
  @ViewChild('container', { static: true }) container: ElementRef<HTMLElement>;
  @ViewChild('mxgraphScriptsContainer', { static: true }) mxgraphScriptsContainer: ElementRef<HTMLElement>;
  graphEditor: GraphEditorIn = new GraphEditor();

  constructor(private spinner: NgxSpinnerService) {}

  ngOnInit(): void {
    this.spinner.show();
    const xml = '<mxGraphModel dx="1038" dy="381" grid="1" gridSize="10" guides="1">...</mxGraphModel>';

    this.graphEditor.initialize(this.container.nativeElement, this.mxgraphScriptsContainer.nativeElement);

    // Load initial data into the graph editor
    this.graphEditor.setGraphEditorData({ xml: xml } as GraphXmlData)
      .then(() => {
        this.spinner.hide();
      })
      .catch((error) => {
        console.error('Failed to set graph data:', error);
        this.spinner.hide();
      });
  }

  // Function to trigger the native file save dialog
  saveDiagram(xml: any): Promise<void> {
    return new Promise(async (resolve, reject) => {
      try {
        const base64Data = xml.image.base64Encoded;
        if (!base64Data) {
          throw new Error('No base64 data found in the XML');
        }

        const img = new Image();
        img.src = 'data:image/svg+xml;base64,' + base64Data;

        img.onload = async () => {
          const canvas = document.createElement('canvas');
          canvas.width = img.width;
          canvas.height = img.height;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0);

          const pngDataUrl = canvas.toDataURL('image/png');

          const handle = await window.showSaveFilePicker({
            suggestedName: `${xml.name || 'diagram'}.png`,
            types: [
              {
                description: 'PNG Image',
                accept: { 'image/png': ['.png'] },
              },
            ],
          });

          const writableStream = await handle.createWritable();
          const blob = await fetch(pngDataUrl).then((res) => res.blob());
          await writableStream.write(blob);
          await writableStream.close();

          resolve();
        };

        img.onerror = (error) => {
          reject(new Error('Failed to load the SVG image: ' + error.message));
        };
      } catch (error) {
        console.error('Save failed:', error);
        reject(error);
      }
    });
  }

  // Function to trigger the native file rename dialog
  async renameDiagram(currentName: string): Promise<void> {
    try {
      const handle = await window.showSaveFilePicker({
        suggestedName: currentName,
        types: [
          {
            description: 'XML File',
            accept: { 'application/vnd.jgraph.mxfile': ['.drawio'] },
          },
        ],
      });

      // Renaming in this context would involve saving the file with a new name
      const writableStream = await handle.createWritable();
      const fileData = '<mxGraphModel dx="1038" dy="381" grid="1" gridSize="10" guides="1">...</mxGraphModel>'; // Replace with actual file data
      await writableStream.write(fileData);
      await writableStream.close();

      console.log('File renamed successfully');
    } catch (error) {
      console.error('Rename failed:', error);
    }
  }
}


.mat-row td,
.mat-row th {
  border-bottom: none;
  vertical-align: middle;
}

.mat-row:nth-child(even) td,
.mat-row:nth-child(even) th {
  background-color: #f9f9f9;
}

<ng-container matColumnDef="date">
    <th mat-header-cell *matHeaderCellDef> Date </th>
    <td mat-cell *matCellDef="let element; let i = index" [attr.rowspan]="shouldMerge(i, 'day') ? rowSpanCount('day') : 1">
      <span *ngIf="shouldMerge(i, 'day')">{{element.day}}</span>
    </td>
  </ng-container>

.mat-cell, .mat-header-cell {
  border: none;
  padding: 8px; /* Adjust padding as needed */
}

.mat-row {
  display: flex;
  align-items: stretch;
  border: 1px solid #ddd; /* Border around the entire row */
  margin-bottom: 8px; /* Spacing between rows */
  border-radius: 4px; /* Optional: rounded corners */
}

.mat-row:hover {
  background-color: #f5f5f5; /* Highlight on hover */
}



export class CopilotDetailsComponent {
  displayedColumns: string[] = [
    'date',
    'total_suggestions_count',
    'total_lines_accepted',
    'total_acceptance_count',
    'total_lines_suggested',
    'total_active_users',
    'language',
    'editor'
  ];
  
  copilotData = [/* your data */];

  shouldMerge(index: number, column: string): boolean {
    const data = this.copilotData.filteredData;
    if (index === 0) return true;
    return data[index][column] !== data[index - 1][column];
  }

  rowSpanCount(column: string): number {
    let count = 1;
    const data = this.copilotData.filteredData;
    for (let i = 1; i < data.length; i++) {
      if (data[i][column] === data[i - 1][column]) {
        count++;
      } else {
        break;
      }
    }
    return count;
  }
}





<ng-container matColumnDef="date">
    <th mat-header-cell *matHeaderCellDef> Date </th>
    <td mat-cell *matCellDef="let element; let i = index" [attr.rowspan]="rowSpanCount('day')">
      {{element.day}}
    </td>
  </ng-container>



<mat-table [dataSource]="copilotData" class="mat-elevation-z8">

  <!-- Date Column -->
  <ng-container matColumnDef="date">
    <th mat-header-cell *matHeaderCellDef> Date </th>
    <td mat-cell *matCellDef="let element"> {{element.date}} </td>
  </ng-container>

  <!-- Total Suggestions Count -->
  <ng-container matColumnDef="total_suggestions_count">
    <th mat-header-cell *matHeaderCellDef> Total Suggestions Count </th>
    <td mat-cell *matCellDef="let element; let i = index" 
        [attr.rowspan]="shouldDisplayRowspan(i) ? copilotData.length : null">
      <span *ngIf="shouldDisplayRowspan(i)">{{element.total_suggestions_count}}</span>
    </td>
  </ng-container>

  <!-- Total Lines Accepted -->
  <ng-container matColumnDef="total_lines_accepted">
    <th mat-header-cell *matHeaderCellDef> Total Lines Accepted </th>
    <td mat-cell *matCellDef="let element; let i = index" 
        [attr.rowspan]="shouldDisplayRowspan(i) ? copilotData.length : null">
      <span *ngIf="shouldDisplayRowspan(i)">{{element.total_lines_accepted}}</span>
    </td>
  </ng-container>

  <!-- Total Acceptance Count -->
  <ng-container matColumnDef="total_acceptance_count">
    <th mat-header-cell *matHeaderCellDef> Total Acceptance Count </th>
    <td mat-cell *matCellDef="let element; let i = index" 
        [attr.rowspan]="shouldDisplayRowspan(i) ? copilotData.length : null">
      <span *ngIf="shouldDisplayRowspan(i)">{{element.total_acceptance_count}}</span>
    </td>
  </ng-container>

  <!-- Total Lines Suggested -->
  <ng-container matColumnDef="total_lines_suggested">
    <th mat-header-cell *matHeaderCellDef> Total Lines Suggested </th>
    <td mat-cell *matCellDef="let element; let i = index" 
        [attr.rowspan]="shouldDisplayRowspan(i) ? copilotData.length : null">
      <span *ngIf="shouldDisplayRowspan(i)">{{element.total_lines_suggested}}</span>
    </td>
  </ng-container>

  <!-- Total Active Users -->
  <ng-container matColumnDef="total_active_users">
    <th mat-header-cell *matHeaderCellDef> Total Active Users </th>
    <td mat-cell *matCellDef="let element; let i = index" 
        [attr.rowspan]="shouldDisplayRowspan(i) ? copilotData.length : null">
      <span *ngIf="shouldDisplayRowspan(i)">{{element.total_active_users}}</span>
    </td>
  </ng-container>

  <!-- Language Column -->
  <ng-container matColumnDef="language">
    <th mat-header-cell *matHeaderCellDef> Language </th>
    <td mat-cell *matCellDef="let element"> {{element.language}} </td>
  </ng-container>

  <!-- Editor Column -->
  <ng-container matColumnDef="editor">
    <th mat-header-cell *matHeaderCellDef> Editor </th>
    <td mat-cell *matCellDef="let element"> {{element.editor}} </td>
  </ng-container>

  <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
  <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>

</mat-table>




openDiagram(): void {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.xml, .png'; // Accept XML and PNG files

    input.onchange = (event: any) => {
        const file = event.target.files[0];
        if (file) {
            let fileName = file.name;
            const fileExtension = fileName.split('.').pop();
            
            // Modify filename if necessary
            if (fileExtension === 'xml' || fileExtension === 'png') {
                fileName = fileName.replace(`.${fileExtension}`, ''); // Remove the extension
            }

            // Perform actions based on the file type
            if (file.type === 'image/png') {
                this.loadPngAsImage(file);
            } else if (file.type === 'application/xml') {
                this.loadDiagramFromFile(file);
            } else {
                console.error('Unsupported file type');
            }
        }
    };

    input.click(); // Trigger the file selection dialog
}

loadDiagramFromFile(file: File): void {
    const reader = new FileReader();
    reader.onload = (event) => {
        try {
            const fileContent = event.target.result as string;
            this.graphEditor.setXml(fileContent); // Load the content into the editor

            // Display the filename without extension
            this.graphEditor.setFileName(file.name.replace('.xml', '')); 

            localStorage.setItem('unsavedDiagram', fileContent); // Save to localStorage to keep track
        } catch (error) {
            console.error('Error loading diagram file', error);
        }
    };
    reader.readAsText(file);
}






import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';
import { NgxSpinnerService } from 'ngx-spinner';
import { GraphEditor } from '@zklogic/draw.io';

@Component({
  selector: 'app-draw-io-details',
  templateUrl: './draw-io-details.component.html',
  styleUrls: ['./draw-io-details.component.scss']
})
export class DrawIoDetailsComponent implements OnInit {
  @ViewChild('container', { static: true }) container: ElementRef<HTMLElement>;
  @ViewChild('mxgraphScriptsContainer', { static: true }) mxgraphScriptsContainer: ElementRef<HTMLElement>;
  graphEditor: GraphEditor;

  constructor(private spinner: NgxSpinnerService) {}

  ngOnInit(): void {
    this.spinner.show();

    // Initialize the graph editor with actions for saving and opening diagrams
    this.graphEditor = new GraphEditor(this.container.nativeElement, this.mxgraphScriptsContainer.nativeElement, {
      actions: {
        save: this.saveDiagram.bind(this),
        open: this.openDiagram.bind(this)
      }
    });

    // Initialize the editor and load any unsaved work from localStorage
    this.graphEditor.initialized(this.container.nativeElement, this.mxgraphScriptsContainer.nativeElement, {
      load: () => this.loadWorkFromLocalStorage().then(() => this.spinner.hide())
    });

    // Listen for changes and save the current work to localStorage
    this.graphEditor.onChange(() => {
      this.saveWorkToLocalStorage();
    });

    // Attach event listener to the "Open from" menu item
    this.attachOpenFromMenuListener();
  }

  attachOpenFromMenuListener(): void {
    // Assuming the "Open from" menu item has a unique identifier or can be selected via a CSS class
    const openFromMenuItem = document.querySelector('[data-action="open"]');
    if (openFromMenuItem) {
      openFromMenuItem.addEventListener('click', (event) => {
        event.preventDefault();
        this.openDiagram();
      });
    }
  }

  saveWorkToLocalStorage(): void {
    const diagramData = this.graphEditor.getXml(); // Get current diagram data in XML format
    localStorage.setItem('unsavedDiagram', diagramData); // Save to localStorage
  }

  loadWorkFromLocalStorage(): Promise<void> {
    return new Promise((resolve) => {
      const savedData = localStorage.getItem('unsavedDiagram');
      if (savedData) {
        this.graphEditor.setXml(savedData); // Load the diagram data into the editor
      }
      resolve();
    });
  }

  saveDiagram(): void {
    const xml = this.graphEditor.getXml();

    // Save the diagram to localStorage to preserve state across tab changes
    localStorage.setItem('savedDiagram', xml);

    // Trigger the download of the diagram as an XML file
    const blob = new Blob([xml], { type: 'application/xml' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'diagram.xml';
    a.click();
  }

  openDiagram(): void {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.xml, .png'; // Accept XML and PNG files

    input.onchange = (event: any) => {
      const file = event.target.files[0];
      if (file) {
        if (file.type === 'image/png') {
          this.loadPngAsImage(file);
        } else if (file.type === 'application/xml') {
          this.loadDiagramFromFile(file);
        }
      }
    };

    input.click(); // Trigger the file selection dialog
  }

  loadDiagramFromFile(file: File): void {
    const reader = new FileReader();
    reader.onload = (event) => {
      const fileContent = event.target.result as string;
      this.graphEditor.setXml(fileContent); // Load the content into the editor
      localStorage.setItem('unsavedDiagram', fileContent); // Save to localStorage to keep track
    };
    reader.readAsText(file);
  }

  loadPngAsImage(file: File): void {
    const reader = new FileReader();
    reader.onload = (event: any) => {
      const imageSrc = event.target.result; // Base64 encoded image
      this.addImageToCanvas(imageSrc);
    };
    reader.readAsDataURL(file); // Read file as Data URL (base64)
  }

  addImageToCanvas(imageSrc: string): void {
    const graph = this.graphEditor.getGraph();
    const model = graph.getModel();

    model.beginUpdate();
    try {
      const parent = graph.getDefaultParent();
      graph.insertVertex(parent, null, '', 20, 20, 200, 200, `shape=image;image=${imageSrc};`);
    } finally {
      model.endUpdate();
    }
  }
}



































import { Component, ElementRef, OnInit, ViewChild } from '@angular/core';
import { NgxSpinnerService } from 'ngx-spinner';
import { GraphEditor } from '@zklogic/draw.io';

@Component({
  selector: 'app-draw-io-details',
  templateUrl: './draw-io-details.component.html',
  styleUrls: ['./draw-io-details.component.scss']
})
export class DrawIoDetailsComponent implements OnInit {
  @ViewChild('container', { static: true }) container: ElementRef<HTMLElement>;
  @ViewChild('mxgraphScriptsContainer', { static: true }) mxgraphScriptsContainer: ElementRef<HTMLElement>;
  graphEditor: GraphEditor;

  constructor(private spinner: NgxSpinnerService) {}

  ngOnInit(): void {
    this.spinner.show();

    // Initialize the graph editor with actions and load any unsaved work
    this.graphEditor = new GraphEditor(this.container.nativeElement, this.mxgraphScriptsContainer.nativeElement, {
      actions: {
        save: this.saveDiagram.bind(this),
        open: this.openDiagram.bind(this)
      }
    });

    this.graphEditor.initialized(this.container.nativeElement, this.mxgraphScriptsContainer.nativeElement, {
      load: () => this.loadWorkFromLocalStorage().then(() => this.spinner.hide())
    });

    // Listen for changes to save to localStorage
    this.graphEditor.onChange(() => {
      this.saveWorkToLocalStorage();
    });
  }

  saveWorkToLocalStorage(): void {
    const diagramData = this.graphEditor.getXml(); // Get current diagram data in XML format
    localStorage.setItem('unsavedDiagram', diagramData); // Save to localStorage
  }

  loadWorkFromLocalStorage(): Promise<void> {
    return new Promise((resolve) => {
      const savedData = localStorage.getItem('unsavedDiagram');
      if (savedData) {
        this.graphEditor.setXml(savedData); // Load the diagram data into the editor
      }
      resolve();
    });
  }

  saveDiagram(): void {
    const xml = this.graphEditor.getXml();

    // Save the diagram to localStorage to preserve state across tab changes
    localStorage.setItem('savedDiagram', xml);

    // Trigger the download of the diagram as an XML file
    const blob = new Blob([xml], { type: 'application/xml' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'diagram.xml';
    a.click();
  }

  openDiagram(): void {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.xml'; // Accept only XML files

    input.onchange = (event: any) => {
      const file = event.target.files[0];
      if (file) {
        this.loadDiagramFromFile(file);
      }
    };

    input.click(); // Trigger the file selection dialog
  }

  loadDiagramFromFile(file: File): void {
    const reader = new FileReader();
    reader.onload = (event) => {
      const fileContent = event.target.result as string;
      this.graphEditor.setXml(fileContent); // Load the content into the editor
      localStorage.setItem('unsavedDiagram', fileContent); // Save to localStorage to keep track
    };
    reader.readAsText(file);
  }
}





















saveDiagram(xml: any): Promise<void> {
    return new Promise((resolve, reject) => {
        try {
            // Extract the Base64 encoded SVG from the XML
            const base64Data = xml.image.base64Encoded;

            if (!base64Data) {
                throw new Error('No base64 data found in the XML');
            }

            // Decode the Base64 string
            const svgData = atob(base64Data);

            // Create an image element
            const img = new Image();
            img.src = 'data:image/svg+xml;base64,' + base64Data;

            img.onload = () => {
                // Create a canvas to render the SVG
                const canvas = document.createElement('canvas');
                canvas.width = img.width;
                canvas.height = img.height;
                const ctx = canvas.getContext('2d');

                // Draw the SVG onto the canvas
                ctx.drawImage(img, 0, 0);

                // Convert the canvas to a PNG data URL
                const pngDataUrl = canvas.toDataURL('image/png');

                // Create a download link for the PNG
                const a = document.createElement('a');
                a.href = pngDataUrl;
                a.download = `${xml.name || 'diagram'}.png`; // Use the diagram name or default
                a.click();

                resolve();
            };

            img.onerror = (error) => {
                reject(new Error('Failed to load the SVG image'));
            };
        } catch (error) {
            console.error('Save failed', error);
            reject(error);
        }
    });
}
